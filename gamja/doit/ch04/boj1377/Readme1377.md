- 버블소트는 기본적으로 시간복잡도가 높다 -> O(N^2) 예제의 c++의 코드를 쓰면 시간초과가 뜬다.
- 그럼 어떤식으로 시간복잡도를 낮출 것인가?
  - 처음 생각한것은 다른 정렬 알고리즘을 써야하나? ex) 버블 정렬을 사용하여 작은 배열을 먼저 정렬하고, 나머지 배열에는 더 빠른 정렬 알고리즘을 사용한다.
  - 문제에서는 flag와 swap의 위치변환등 이미 효율적으로 사용한 것 같아. 이부분의 개선점은 잘 모르겠다.

  
> 참고자료 : https://steady-coding.tistory.com/41

- 문제에서는 더 이상 정렬이 발생하지 않는 인덱스를 구하라고 되어 있다. 
- 즉 왼쪽으로 가장 많이 이동한 숫자가  우리가 구하고자 하는 숫자이다.
그 이유는 가장 많이 이동했다면 이동 할동안 다른 숫자들은 오른쪽으로 이동 했기 때문.


- 어려운 점 : 이 방법 말고는 생각이 안난다. 이 방법을 스스로 도출 하지못함.

